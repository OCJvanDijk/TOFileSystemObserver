//
//  TOFileSystemList.m
//  TOFileSystemObserverExample
//
//  Created by Tim Oliver on 10/11/19.
//  Copyright Â© 2019 Tim Oliver. All rights reserved.
//

#import "TOFileSystemItemList.h"
#import "TOFileSystemItem.h"
#import "TOFileSystemItem+Private.h"
#import "TOFileSystemObserver.h"
#import "TOFileSystemPath.h"
#import "TOFileSystemPresenter.h"
#import "TOFileSystemNotificationToken.h"
#import "TOFileSystemNotificationToken+Private.h"
#import "TOFileSystemItemListChanges.h"
#import "TOFileSystemItemListChanges+Private.h"

#import "NSURL+TOFileSystemUUID.h"
#import "NSFileManager+TOFileSystemDirectoryEnumerator.h"

@interface TOFileSystemItemList () <TOFileSystemNotifying>

/** The UUID string of the directory backing this object */
@property (nonatomic, copy, readwrite) NSString *uuid;

/** A weak reference to the observer object we were created by. */
@property (nonatomic, weak, readwrite) TOFileSystemObserver *fileSystemObserver;

/** A writeable copy of the location of this directory */
@property (nonatomic, strong, readwrite) NSURL *directoryURL;

/** Store a bookmark to this item in case the user moves it while it's open. */
@property (nonatomic, strong) NSData *bookmarkData;

/** An dictionary of the items in this dictionary, stored by their UUID. */
@property (nonatomic, strong) NSMutableDictionary<NSString *, TOFileSystemItem *> *items;

/** An array of the item UUIDs, sorted in the order specified. */
@property (nonatomic, strong) NSMutableArray<NSString *> *sortedItems;

/** A set that holds all of the notification tokens generated by this list */
@property (nonatomic, strong) NSHashTable *notificationTokens;

@end

@implementation TOFileSystemItemList

- (instancetype)initWithDirectoryURL:(NSURL *)directoryURL
                  fileSystemObserver:(TOFileSystemObserver *)observer
{
    if (self = [super init]) {
        _fileSystemObserver = observer;
        _directoryURL = directoryURL;
        _uuid = [directoryURL to_makeFileSystemUUIDIfNeeded];
        [self commonInit];
    }
    
    return self;
}

- (void)commonInit
{
    // Create a bookmark object to let us track this URL if the user moves it
    _bookmarkData = [_directoryURL bookmarkDataWithOptions:NSURLBookmarkCreationMinimalBookmark
                            includingResourceValuesForKeys:nil
                                             relativeToURL:[TOFileSystemPath applicationSandboxURL]
                                                     error:nil];
    
    // Create the file list stores
    _items = [NSMutableDictionary dictionary];
    _sortedItems = [NSMutableArray array];
}

- (void)buildItemsList
{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSDirectoryEnumerator *enumerator = [fileManager to_fileSystemEnumeratorForDirectoryAtURL:_directoryURL];
    
    // Build a new list of files from what is currently on disk
    for (NSURL *url in enumerator) {
        TOFileSystemItem *item = [self.fileSystemObserver itemForFileAtURL:url];

        // Add the list to the item's store so it can notify of updates
        [item addToList:self];
        
        // Capture the item with its UUID in the dictionary
        _items[item.uuid] = item;
    }
    
    // Sort according to our current sort settings
    _sortedItems = _items.allKeys.mutableCopy;
    [self sortItemsList];
}

- (void)rebuildItemListForListingOrder
{
    if (self.sortedItems.count == 0) { return; }
    
    // Grab a copy of the current list
    NSArray *previousList = [self.sortedItems copy];
    
    // Sort the list to the new order
    [self sortItemsList];
    
    // Loop through and build a list of indices for each moved cell.
    TOFileSystemItemListChanges *changes = [[TOFileSystemItemListChanges alloc] init];
    for (NSInteger i = 0; i < previousList.count; i++) {
        // Work out where the item in the new list went
        NSInteger newIndex = [self sortedIndexForItemWithUUID:previousList[i]];
        [changes addMovementWithSourceIndex:i destinationIndex:newIndex];
    }
    
    // Trigger the notification blocks to update any UI with this new order
    for (TOFileSystemNotificationToken *token in self.notificationTokens) {
        token.notificationBlock(self, changes);
    }
}

#pragma mark - Sorting Items -

- (NSComparator)sortComparator
{
    __weak typeof(self) weakSelf = self;
    return ^NSComparisonResult(NSString *firstUUID, NSString *secondUUID) {
        TOFileSystemItem *firstItem = weakSelf.items[firstUUID];
        TOFileSystemItem *secondItem = weakSelf.items[secondUUID];
        
        // If the order is flipped, swap around the two items
        if (self.isDescending) {
            TOFileSystemItem *tempItem = firstItem;
            firstItem = secondItem;
            secondItem = tempItem;
        }
        
        switch (weakSelf.listOrder) {
            case TOFileSystemItemListOrderAlphanumeric:
                return [firstItem.name localizedStandardCompare:secondItem.name];
            case TOFileSystemItemListOrderDate:
                return [firstItem.modificationDate compare:secondItem.modificationDate];
            default:
                return firstItem.size > secondItem.size;
        }
    };
}

- (void)sortItemsList
{
    // Sort all of the UUIDS
    [_sortedItems sortUsingComparator:self.sortComparator];
}

- (NSUInteger)sortedIndexForItemWithUUID:(NSString *)uuid
{
    return [self.sortedItems indexOfObject:uuid
                             inSortedRange:(NSRange){0, self.sortedItems.count}
                                   options:NSBinarySearchingInsertionIndex
                           usingComparator:self.sortComparator];
}

#pragma mark - External Item Access -

- (NSUInteger)count
{
    // Lazy-load the list when we query for the first time.
    if (self.sortedItems.count == 0) {
        [self buildItemsList];
    }
    
    return self.items.count;
}

- (TOFileSystemItem *)objectAtIndex:(NSUInteger)index
{
    return self.items[self.sortedItems[index]];
}

- (id)objectAtIndexedSubscript:(NSUInteger)index
{
    return self.items[self.sortedItems[index]];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state
                                  objects:(id __unsafe_unretained _Nullable [_Nonnull])buffer
                                    count:(NSUInteger)len
{
    return [_items countByEnumeratingWithState:state
                                       objects:buffer
                                         count:len];
}

#pragma mark - Live Item Updating -

- (void)addItemWithUUID:(NSString *)uuid itemURL:(NSURL *)url
{
    // Skip if this item is already in the list
    if (self.items[uuid]) { return; }
    
    // Generate a new item and add it to our list
    TOFileSystemItem *item = [self.fileSystemObserver itemForFileAtURL:url];
    [item addToList:self];
    self.items[item.uuid] = item;
    
    // Work out where the item should go in our sorted list
    NSUInteger sortedIndex = [self sortedIndexForItemWithUUID:item.uuid];
    [self.sortedItems insertObject:item.uuid atIndex:sortedIndex];
    
    // Perform the broadcast to any observing objects that this update ocurred
    TOFileSystemItemListChanges *changes = [[TOFileSystemItemListChanges alloc] init];
    [changes addInsertionIndex:sortedIndex];
    for (TOFileSystemNotificationToken *token in self.notificationTokens) {
        token.notificationBlock(self, changes);
    }
}

- (void)removeItemWithUUID:(NSString *)uuid fileURL:(NSURL *)url
{
    [self.items removeObjectForKey:uuid];
    [self.sortedItems removeObject:uuid];
}

- (void)itemDidRefreshWithUUID:(NSString *)uuid
{

}

#pragma mark - Notification Token -

- (TOFileSystemNotificationToken *)addNotificationBlock:(TOFileSystemItemListNotificationBlock)block
{
    TOFileSystemNotificationToken *token = [TOFileSystemNotificationToken tokenWithObservingObject:self block:block];
    if (self.notificationTokens == nil) {
        self.notificationTokens = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
    }
    [self.notificationTokens addObject:token];
    return token;
}

- (void)removeNotificationToken:(TOFileSystemNotificationToken *)token
{
    [self.notificationTokens removeObject:token];
}

#pragma mark - Accessors -

- (void)setListOrder:(TOFileSystemItemListOrder)listOrder
{
    if (_listOrder == listOrder) { return; }
    _listOrder = listOrder;
    
}

- (void)setIsDescending:(BOOL)isDescending
{
    if (_isDescending == isDescending) { return; }
    _isDescending = isDescending;
}

#pragma mark - Debugging -

- (NSString *)description
{
    return [NSString stringWithFormat:@"url = '%@', uuid = '%@', listOrder = %ld, isDescending = %d, items = '%@'",
            _directoryURL,
            _uuid,
            (long)_listOrder,
            _isDescending,
            _items];
}

@end
